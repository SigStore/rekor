// Code generated by go-swagger; DO NOT EDIT.

package restapi

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/xml",
    "application/yaml"
  ],
  "produces": [
    "application/json",
    "application/xml",
    "application/yaml"
  ],
  "swagger": "2.0",
  "info": {
    "description": "Rekor is a cryptographically secure, immutable transparency log for signed software releases.",
    "title": "Rekor",
    "version": "0.0.1"
  },
  "paths": {
    "/api/v1/log": {
      "get": {
        "description": "Returns the current root hash and size of the merkle tree used to store the log entries.",
        "tags": [
          "tlog"
        ],
        "summary": "Get information about the current state of the transparency log",
        "operationId": "getLogInfo",
        "responses": {
          "200": {
            "description": "A JSON object with the root hash and tree size as properties",
            "schema": {
              "$ref": "#/definitions/LogInfo"
            }
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    },
    "/api/v1/log/entries": {
      "get": {
        "tags": [
          "entries"
        ],
        "summary": "Retrieves an entry from the transparency log (if it exists) by index",
        "operationId": "getLogEntryByIndex",
        "parameters": [
          {
            "type": "integer",
            "description": "specifies the index of the entry in the transparency log to be retrieved",
            "name": "logIndex",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "the entry in the transparency log requested",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      },
      "post": {
        "description": "Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\n",
        "tags": [
          "entries"
        ],
        "summary": "Creates an entry in the transparency log",
        "operationId": "createLogEntry",
        "parameters": [
          {
            "name": "proposedEntry",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/ProposedEntry"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Returns the entry created in the transparency log",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            },
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "URI location of log entry"
              }
            }
          },
          "400": {
            "$ref": "#/responses/BadContent"
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    },
    "/api/v1/log/entries/retrieve": {
      "post": {
        "tags": [
          "entries"
        ],
        "summary": "Searches transparency log for one or more log entries",
        "operationId": "searchLogQuery",
        "parameters": [
          {
            "name": "entry",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchLogQuery"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns zero or more entries from the transparency log, according to how many were included in request query",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/LogEntry"
              }
            }
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    },
    "/api/v1/log/entries/{entryUUID}": {
      "get": {
        "tags": [
          "entries"
        ],
        "summary": "Retrieves an entry from the transparency log (if it exists) by UUID",
        "operationId": "getLogEntryByUUID",
        "parameters": [
          {
            "type": "string",
            "description": "the UUID of the entry to be retrieved from the log. The UUID is also the merkle tree hash of the entry.",
            "name": "entryUUID",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "the entry in the transparency log requested",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    },
    "/api/v1/log/entries/{entryUUID}/proof": {
      "get": {
        "description": "Returns root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log",
        "tags": [
          "entries"
        ],
        "summary": "Get information required to generate an inclusion proof for a specified entry in the transparency log",
        "operationId": "getLogEntryProof",
        "parameters": [
          {
            "type": "string",
            "description": "the UUID of the entry for which the inclusion proof information should be returned",
            "name": "entryUUID",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Information needed for a client to compute the inclusion proof",
            "schema": {
              "$ref": "#/definitions/InclusionProof"
            }
          },
          "404": {
            "$ref": "#/responses/NotFound"
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    },
    "/api/v1/log/proof": {
      "get": {
        "description": "Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log",
        "tags": [
          "tlog"
        ],
        "summary": "Get information required to generate a consistency proof for the transparency log",
        "operationId": "getLogProof",
        "parameters": [
          {
            "type": "integer",
            "default": 0,
            "description": "The size of the tree that you wish to prove consistency from (0 means the beginning of the log) Defaults to 0 if not specified\n",
            "name": "firstSize",
            "in": "query"
          },
          {
            "type": "integer",
            "description": "The size of the tree that you wish to prove consistency to",
            "name": "lastSize",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "All hashes required to compute the consistency proof",
            "schema": {
              "$ref": "#/definitions/ConsistencyProof"
            }
          },
          "default": {
            "$ref": "#/responses/InternalServerError"
          }
        }
      }
    }
  },
  "definitions": {
    "ConsistencyProof": {
      "type": "object",
      "required": [
        "firstRootHash",
        "lastRootHash",
        "hashes"
      ],
      "properties": {
        "firstRootHash": {
          "description": "The hash value stored at the root of the merkle tree at the first size specified",
          "type": "string"
        },
        "hashes": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[0-9a-fA-F]{64}$"
          }
        },
        "lastRootHash": {
          "description": "The hash value stored at the root of the merkle tree at the last size specified",
          "type": "string"
        }
      }
    },
    "Error": {
      "type": "object",
      "required": [
        "type",
        "title",
        "status"
      ],
      "properties": {
        "detail": {
          "type": "string"
        },
        "status": {
          "type": "integer"
        },
        "title": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "InclusionProof": {
      "type": "object",
      "required": [
        "logIndex",
        "rootHash",
        "treeSize",
        "hashes"
      ],
      "properties": {
        "hashes": {
          "description": "A list of hashes required to compute the inclusion proof, sorted in order from leaf to root",
          "type": "array",
          "items": {
            "description": "SHA256 hash value expressed in hexadecimal format",
            "type": "string",
            "pattern": "^[0-9a-fA-F]{64}$"
          }
        },
        "logIndex": {
          "description": "The index of the entry in the transparency log",
          "type": "integer"
        },
        "rootHash": {
          "description": "The hash value stored at the root of the merkle tree",
          "type": "string",
          "pattern": "^[0-9a-fA-F]{64}$"
        },
        "treeSize": {
          "description": "The size of the merkle tree at the time the inclusion proof was generated",
          "type": "integer"
        }
      }
    },
    "LogEntry": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "required": [
          "logIndex",
          "signature",
          "signedContentSHA256"
        ],
        "properties": {
          "extraData": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "logIndex": {
            "type": "integer"
          },
          "signature": {
            "type": "object",
            "required": [
              "format",
              "content",
              "publicKey"
            ],
            "properties": {
              "content": {
                "type": "string",
                "format": "byte"
              },
              "format": {
                "$ref": "#/definitions/SupportedPKIFormats"
              },
              "publicKey": {
                "type": "string",
                "format": "byte"
              }
            }
          },
          "signedContentSHA256": {
            "type": "string",
            "pattern": "^[0-9a-fA-F]{64}$"
          }
        }
      }
    },
    "LogInfo": {
      "type": "object",
      "required": [
        "rootHash",
        "treeSize"
      ],
      "properties": {
        "rootHash": {
          "description": "The current hash value stored at the root of the merkle tree",
          "type": "string"
        },
        "treeSize": {
          "description": "The current number of nodes in the merkle tree",
          "type": "integer"
        }
      }
    },
    "ProposedEntry": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "properties": {
            "content": {
              "description": "Base64-encoded content.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "byte"
            },
            "sha256": {
              "description": "The SHA256 hash of the content located at the URL specified in the 'url' parameter. This property is required when 'url' is specified, and ignored when 'content' is specified.\n",
              "type": "string",
              "pattern": "^[0-9a-fA-F]{64}$"
            },
            "url": {
              "description": "The URL where the content refered to in the signature property is located. When specifying 'url', you must also specify the 'sha256' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "uri"
            }
          }
        },
        "signature": {
          "type": "object",
          "required": [
            "format",
            "publicKey"
          ],
          "properties": {
            "content": {
              "type": "string",
              "format": "byte"
            },
            "format": {
              "$ref": "#/definitions/SupportedPKIFormats"
            },
            "publicKey": {
              "type": "object",
              "properties": {
                "content": {
                  "description": "Base64-encoded content of the public key. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
                  "type": "string",
                  "format": "byte"
                },
                "url": {
                  "description": "The URL where the public key can be found. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
                  "type": "string",
                  "format": "uri"
                }
              }
            },
            "url": {
              "type": "string",
              "format": "uri"
            }
          }
        }
      }
    },
    "SearchLogQuery": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "minItems": 1,
            "$ref": "#/definitions/LogEntry"
          }
        },
        "entryUUIDs": {
          "type": "array",
          "items": {
            "type": "string",
            "minItems": 1
          }
        },
        "logIndexes": {
          "type": "array",
          "items": {
            "type": "integer",
            "minItems": 1
          }
        }
      }
    },
    "SupportedPKIFormats": {
      "description": "This represents the tokens that indicate the format of the PKI artifacts supported by the server",
      "type": "string",
      "enum": [
        "pgp"
      ]
    }
  },
  "responses": {
    "BadContent": {
      "description": "The content supplied to the server was invalid",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    },
    "InternalServerError": {
      "description": "There was an internal error in the server while processing the request",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    },
    "NotFound": {
      "description": "The content requested could not be found",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    }
  }
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/xml",
    "application/yaml"
  ],
  "produces": [
    "application/json",
    "application/xml",
    "application/yaml"
  ],
  "swagger": "2.0",
  "info": {
    "description": "Rekor is a cryptographically secure, immutable transparency log for signed software releases.",
    "title": "Rekor",
    "version": "0.0.1"
  },
  "paths": {
    "/api/v1/log": {
      "get": {
        "description": "Returns the current root hash and size of the merkle tree used to store the log entries.",
        "tags": [
          "tlog"
        ],
        "summary": "Get information about the current state of the transparency log",
        "operationId": "getLogInfo",
        "responses": {
          "200": {
            "description": "A JSON object with the root hash and tree size as properties",
            "schema": {
              "$ref": "#/definitions/LogInfo"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    },
    "/api/v1/log/entries": {
      "get": {
        "tags": [
          "entries"
        ],
        "summary": "Retrieves an entry from the transparency log (if it exists) by index",
        "operationId": "getLogEntryByIndex",
        "parameters": [
          {
            "type": "integer",
            "description": "specifies the index of the entry in the transparency log to be retrieved",
            "name": "logIndex",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "the entry in the transparency log requested",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            }
          },
          "404": {
            "description": "The content requested could not be found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      },
      "post": {
        "description": "Creates an entry in the transparency log for a detached signature, public key, and content. Items can be included in the request or fetched by the server when URLs are specified.\n",
        "tags": [
          "entries"
        ],
        "summary": "Creates an entry in the transparency log",
        "operationId": "createLogEntry",
        "parameters": [
          {
            "name": "proposedEntry",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/ProposedEntry"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Returns the entry created in the transparency log",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            },
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "URI location of log entry"
              }
            }
          },
          "400": {
            "description": "The content supplied to the server was invalid",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    },
    "/api/v1/log/entries/retrieve": {
      "post": {
        "tags": [
          "entries"
        ],
        "summary": "Searches transparency log for one or more log entries",
        "operationId": "searchLogQuery",
        "parameters": [
          {
            "name": "entry",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchLogQuery"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns zero or more entries from the transparency log, according to how many were included in request query",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/LogEntry"
              }
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    },
    "/api/v1/log/entries/{entryUUID}": {
      "get": {
        "tags": [
          "entries"
        ],
        "summary": "Retrieves an entry from the transparency log (if it exists) by UUID",
        "operationId": "getLogEntryByUUID",
        "parameters": [
          {
            "type": "string",
            "description": "the UUID of the entry to be retrieved from the log. The UUID is also the merkle tree hash of the entry.",
            "name": "entryUUID",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "the entry in the transparency log requested",
            "schema": {
              "$ref": "#/definitions/LogEntry"
            }
          },
          "404": {
            "description": "The content requested could not be found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    },
    "/api/v1/log/entries/{entryUUID}/proof": {
      "get": {
        "description": "Returns root hash, tree size, and a list of hashes that can be used to calculate proof of an entry being included in the transparency log",
        "tags": [
          "entries"
        ],
        "summary": "Get information required to generate an inclusion proof for a specified entry in the transparency log",
        "operationId": "getLogEntryProof",
        "parameters": [
          {
            "type": "string",
            "description": "the UUID of the entry for which the inclusion proof information should be returned",
            "name": "entryUUID",
            "in": "path",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "Information needed for a client to compute the inclusion proof",
            "schema": {
              "$ref": "#/definitions/InclusionProof"
            }
          },
          "404": {
            "description": "The content requested could not be found",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    },
    "/api/v1/log/proof": {
      "get": {
        "description": "Returns a list of hashes for specified tree sizes that can be used to confirm the consistency of the transparency log",
        "tags": [
          "tlog"
        ],
        "summary": "Get information required to generate a consistency proof for the transparency log",
        "operationId": "getLogProof",
        "parameters": [
          {
            "minimum": 0,
            "type": "integer",
            "default": 0,
            "description": "The size of the tree that you wish to prove consistency from (0 means the beginning of the log) Defaults to 0 if not specified\n",
            "name": "firstSize",
            "in": "query"
          },
          {
            "minimum": 0,
            "type": "integer",
            "description": "The size of the tree that you wish to prove consistency to",
            "name": "lastSize",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "All hashes required to compute the consistency proof",
            "schema": {
              "$ref": "#/definitions/ConsistencyProof"
            }
          },
          "default": {
            "description": "There was an internal error in the server while processing the request",
            "schema": {
              "$ref": "#/definitions/Error"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "ConsistencyProof": {
      "type": "object",
      "required": [
        "firstRootHash",
        "lastRootHash",
        "hashes"
      ],
      "properties": {
        "firstRootHash": {
          "description": "The hash value stored at the root of the merkle tree at the first size specified",
          "type": "string"
        },
        "hashes": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[0-9a-fA-F]{64}$"
          }
        },
        "lastRootHash": {
          "description": "The hash value stored at the root of the merkle tree at the last size specified",
          "type": "string"
        }
      }
    },
    "Error": {
      "type": "object",
      "required": [
        "type",
        "title",
        "status"
      ],
      "properties": {
        "detail": {
          "type": "string"
        },
        "status": {
          "type": "integer"
        },
        "title": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "InclusionProof": {
      "type": "object",
      "required": [
        "logIndex",
        "rootHash",
        "treeSize",
        "hashes"
      ],
      "properties": {
        "hashes": {
          "description": "A list of hashes required to compute the inclusion proof, sorted in order from leaf to root",
          "type": "array",
          "items": {
            "description": "SHA256 hash value expressed in hexadecimal format",
            "type": "string",
            "pattern": "^[0-9a-fA-F]{64}$"
          }
        },
        "logIndex": {
          "description": "The index of the entry in the transparency log",
          "type": "integer"
        },
        "rootHash": {
          "description": "The hash value stored at the root of the merkle tree",
          "type": "string",
          "pattern": "^[0-9a-fA-F]{64}$"
        },
        "treeSize": {
          "description": "The size of the merkle tree at the time the inclusion proof was generated",
          "type": "integer"
        }
      }
    },
    "LogEntry": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/LogEntryAnon"
      }
    },
    "LogEntryAnon": {
      "type": "object",
      "required": [
        "logIndex",
        "signature",
        "signedContentSHA256"
      ],
      "properties": {
        "extraData": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "logIndex": {
          "type": "integer"
        },
        "signature": {
          "type": "object",
          "required": [
            "format",
            "content",
            "publicKey"
          ],
          "properties": {
            "content": {
              "type": "string",
              "format": "byte"
            },
            "format": {
              "$ref": "#/definitions/SupportedPKIFormats"
            },
            "publicKey": {
              "type": "string",
              "format": "byte"
            }
          }
        },
        "signedContentSHA256": {
          "type": "string",
          "pattern": "^[0-9a-fA-F]{64}$"
        }
      }
    },
    "LogEntryAnonSignature": {
      "type": "object",
      "required": [
        "format",
        "content",
        "publicKey"
      ],
      "properties": {
        "content": {
          "type": "string",
          "format": "byte"
        },
        "format": {
          "$ref": "#/definitions/SupportedPKIFormats"
        },
        "publicKey": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "LogInfo": {
      "type": "object",
      "required": [
        "rootHash",
        "treeSize"
      ],
      "properties": {
        "rootHash": {
          "description": "The current hash value stored at the root of the merkle tree",
          "type": "string"
        },
        "treeSize": {
          "description": "The current number of nodes in the merkle tree",
          "type": "integer"
        }
      }
    },
    "ProposedEntry": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "properties": {
            "content": {
              "description": "Base64-encoded content.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "byte"
            },
            "sha256": {
              "description": "The SHA256 hash of the content located at the URL specified in the 'url' parameter. This property is required when 'url' is specified, and ignored when 'content' is specified.\n",
              "type": "string",
              "pattern": "^[0-9a-fA-F]{64}$"
            },
            "url": {
              "description": "The URL where the content refered to in the signature property is located. When specifying 'url', you must also specify the 'sha256' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "uri"
            }
          }
        },
        "signature": {
          "type": "object",
          "required": [
            "format",
            "publicKey"
          ],
          "properties": {
            "content": {
              "type": "string",
              "format": "byte"
            },
            "format": {
              "$ref": "#/definitions/SupportedPKIFormats"
            },
            "publicKey": {
              "type": "object",
              "properties": {
                "content": {
                  "description": "Base64-encoded content of the public key. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
                  "type": "string",
                  "format": "byte"
                },
                "url": {
                  "description": "The URL where the public key can be found. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
                  "type": "string",
                  "format": "uri"
                }
              }
            },
            "url": {
              "type": "string",
              "format": "uri"
            }
          }
        }
      }
    },
    "ProposedEntryData": {
      "type": "object",
      "properties": {
        "content": {
          "description": "Base64-encoded content.\nThe 'url' and 'content' properties are mutually exclusive.\n",
          "type": "string",
          "format": "byte"
        },
        "sha256": {
          "description": "The SHA256 hash of the content located at the URL specified in the 'url' parameter. This property is required when 'url' is specified, and ignored when 'content' is specified.\n",
          "type": "string",
          "pattern": "^[0-9a-fA-F]{64}$"
        },
        "url": {
          "description": "The URL where the content refered to in the signature property is located. When specifying 'url', you must also specify the 'sha256' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
          "type": "string",
          "format": "uri"
        }
      }
    },
    "ProposedEntrySignature": {
      "type": "object",
      "required": [
        "format",
        "publicKey"
      ],
      "properties": {
        "content": {
          "type": "string",
          "format": "byte"
        },
        "format": {
          "$ref": "#/definitions/SupportedPKIFormats"
        },
        "publicKey": {
          "type": "object",
          "properties": {
            "content": {
              "description": "Base64-encoded content of the public key. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "byte"
            },
            "url": {
              "description": "The URL where the public key can be found. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
              "type": "string",
              "format": "uri"
            }
          }
        },
        "url": {
          "type": "string",
          "format": "uri"
        }
      }
    },
    "ProposedEntrySignaturePublicKey": {
      "type": "object",
      "properties": {
        "content": {
          "description": "Base64-encoded content of the public key. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
          "type": "string",
          "format": "byte"
        },
        "url": {
          "description": "The URL where the public key can be found. This public key needs to be the pair of the private key used to generate the detached signature found in the 'signature' property.\nThe 'url' and 'content' properties are mutually exclusive.\n",
          "type": "string",
          "format": "uri"
        }
      }
    },
    "SearchLogQuery": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "minItems": 1,
            "$ref": "#/definitions/LogEntry"
          }
        },
        "entryUUIDs": {
          "type": "array",
          "items": {
            "type": "string",
            "minItems": 1
          }
        },
        "logIndexes": {
          "type": "array",
          "items": {
            "type": "integer",
            "minItems": 1
          }
        }
      }
    },
    "SupportedPKIFormats": {
      "description": "This represents the tokens that indicate the format of the PKI artifacts supported by the server",
      "type": "string",
      "enum": [
        "pgp"
      ]
    }
  },
  "responses": {
    "BadContent": {
      "description": "The content supplied to the server was invalid",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    },
    "InternalServerError": {
      "description": "There was an internal error in the server while processing the request",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    },
    "NotFound": {
      "description": "The content requested could not be found",
      "schema": {
        "$ref": "#/definitions/Error"
      }
    }
  }
}`))
}
